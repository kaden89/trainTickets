# Система покупки ж/д билетов

# Принцип работы:

1) Пользователь авторизуется в приложении<br />
2) По дате и пункту отправления/прибытия получает список возможных поездок на эту дату<br />
3) По выбранной поездке получает список доступных к бронированию билетов<br />
4) Бронирует нужный билет (по умолчанию на 10 мин)<br />
5) Совершает покупку забронированного билета<br />

# Rest API
<b>Список поездок:</b> `GET /api/v1/trips/?departureId=1&destinationId=2&date=2017-09-1`<br />
<b>Список доступных билетов поездки (исключая купленные и забронированные):</b>`GET /api/v1/trips/{tripId}/tickets`<br />
<b>Бронирование билета:</b>`POST /api/v1/trips/{tripId}/tickets/{ticketId}/reserve`<br />
<b>Покупка билета:</b>`POST /api/v1/trips/{tripId}/tickets/{ticketId}/buy`<br />

# Реализация:
<b>БД:</b> <br />
Определены справочные таблицы: <br />
Пользователи(USERS), <br />
Города(CITIES), <br />
Поезда(TRAINS) - Содержит номер, ссылается на состав вагонов, <br />
Вагоны(WAGONS) - Содержит номер, тип(Купе/Плацкарт), количество мест, <br />
Билеты(TICKETS) - Ссылается на поездку, вагон. Содержит информацию о номере, номере места, цена, статус (доступно/продано)<br />
и связочные: <br />
Поездки(TRIPS) - Отражает маршруты, ссылается на города (отправка/прибытие), поезд и билеты на этот маршрут. Содержит информацию о дате и времени отбытия/прибытия, <br />
Бронирование(RESERVATIONS) <br />
Процессы оплаты билетов(TICKET_TRANSACTIONS)<br />
Такая декомпозиция позволит например по поездке сгенерировать билеты на продажу с учетом количества и типом мест, а также хранить историю бронирования/покупок<br />

Проставлены индексы по поисковым полям<br />
<br />
<b>Процесс оплаты:</b> <br />
Т.к. процесс оплаты билета может быть сложным и занимать длительное время, необходимо предусмотреть систему бронирования билетов, чтобы исключить попытку покупки одного билета разными пользователями.
Система бронирования это таблица пользователь-билет-время окончания бронирования. При попытке бронирования билета происходит запрос к таблице бронирования который сравнивает текущее время с максимальным из таблицы бронирования для конкретного билета.
Если текущее время больше либо таблица бронирования для конкретного билета пуста, то пользователю разрешается забронировать билет. Такая проверка необходима на случай если один пользователь **уже** забронировал билет, а второй пытается забронировать тот же самый (например в результате устаревших данных на ui)
Чтобы избежать возможности бронирования одного и того же билета **в одно и то же время** несколькими пользователями применяется оптимистичная блокировка по таблице билета, путем принудительного повышения версии билета при бронировании. Т.е. забронирует первый успевший.<br />
Т.к. бронирование выполняется в отдельной таблице, это позволяет легко снимать бронь, а так же решает проблему истечения брони:
Если бы мы хранили информацию о бронировании билета в самом билете, то при истечении брони нам бы пришлось искать способ ее динамического снятия(например проходом по всей таблице билетов)<br />
Денежные транзакции также должны хранится в отдельной таблице как минимум для истории. Также т.к. модель билета не хранит купившего его пользователя (т.к. у не проданных билетов там будет NULL, а их следует избегать в обычных таблицах), эта таблица может использоваться для получения таких данных<br />

Логика покрыта базовыми тестами по тестовым данным(populateDB.sql)



